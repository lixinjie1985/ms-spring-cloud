https://github.com/Netflix/Hystrix/wiki
What Is Hystrix?
在一个分布式环境，一些依赖的服务失败是不可避免的，hystrix帮助你控制分布式服务之间的交互，通过添加延迟容忍和错误容忍逻辑。
hystrix通过隔离服务之间的访问点，阻止它们之间的级联失败，提供后退一步选项，所有这些都是为了改进系统整体的迅速恢复能力。
What Is Hystrix For?
hystrix被设计为以下目的：
对通过第三方客户端库的依赖访问（典型地通过网络）提供保护和控制延时和失败。
在复杂的分布式系统中阻止级联失败。
快速失败和迅速恢复。
当可能时，进行回退和优雅降级。
能够接近实时的监控、告警和可操作控制。
What Problem Does Hystrix Solve?
如果主应用不和外部的失败隔离开，它存在被拖垮的风险。如果一个应用依赖30个服务，每个服务都是99.99%运行。30个就是99.99%的30次方
是99.7%，0.3%的失败率，10亿次请求就会有300万次失败。即使所有服务都运行良好，每个月也有大于2小时的宕机时间。现实世界的情况一般
更加糟糕。
当有一个后端系统出现延迟时，所有的请求都会阻塞到那里，在一个高流量系统里，所有服务器的所有资源会瞬间变的饱和。应用程序中的任何
一点只要有网络请求的都会是潜在失败的源，比失败更可怕的是，这会导致服务间延迟的增加，背后的队列、线程和其它系统资源会导致甚至更多
的级联失败。这个问题会加剧，当网络访问通过一个第三方客户端（一个黑盒子）时，它的实现细节被隐藏并且可能在任何时候改变，网络和资源
配置对于每个客户端库都不一样，且通常比较难监控和改变。更糟糕的是传递依赖，执行那些没有被应用显式调用的但潜在可能昂贵的或有错误倾向
的网络调用。网路链接失败或降级，服务和服务器失败或变慢，新的库或服务的部署改变了行为或性能特征，客户端库有bug。
所有这些表示失败和延迟需要被隔离和管理，以便一个单独的小的失败不会把整个应用或系统拖垮。
什么作为hystrix的设计原则？
阻止任何单个依赖用完容器所有的用户线程。
摆脱负载和快速失败而不是排队。
任何地方只要可行的都提供退路来保护用户不失败。
使用隔离技术来限制任何一个依赖的冲击。
通过接近实时的衡量、监控和告警优化发现时间。
通过配置改变的低延时传播，支持多方面的动态属性修改，允许低延时循环反馈的可操作低延时修改来优化发现时间。
保证整个依赖客户端执行不失败，而不仅仅在网络流量。
How Does Hystrix Accomplish Its Goals?
把所有对外部系统（或依赖）的调用包装到一个HystrixCommand或HystrixObservableCommand对象里，它在一个单独的线程里执行。
超时调用比你定义的阈值花费更长的时间。有一个默认值，但是对于大多数依赖可以通过属性自定义超时时间，以便对于每个依赖，它们比衡量的第99.5个百分比性能稍微高一些。
为每一个依赖维护一个小的线程池（或信号量），如果它变满了，对该依赖的请求将被立即拒绝而不是排起长队。
测量成功、失败、超时和线程拒绝的数量。
设置一个循环断路器阻止到一个服务的所有请求一段时间，或者人工的或者自动的，如果该服务的错误百分比超过一个阈值。
执行后退逻辑当一个请求失败、被拒绝、超时或短路。
以近乎实时地监控指标和配置改变。
当你使用hystrix包装每一个底层依赖时，架构变成类似于下图这样，每一个依赖相互隔离，限制在资源里，当延迟发生时它能够饱和，
覆盖在回退逻辑里，当依赖里发生任何类型的失败时来决定产生什么响应。
https://github.com/Netflix/Hystrix/wiki/How-it-Works
Flow Chart
1. Construct a HystrixCommand or HystrixObservableCommand Object
2. Execute the Command
有四种方式可以执行命令，分别对应四个方法。
execute()，同步执行返回结果或抛出异常。
queue()，异步执行返回Future，可判断是否结束并获取结果。
observe()，订阅到表示响应的Observable，并且返回这个Observable的一个副本。
toObservable()，返回一个Observable，当你订阅它时，将执行并发出响应。
execute()相等于调用queue().get()。queue()相等于调用toObservable().toBlocking().toFuture()。也就是说最后每一个命令后面
都是一个Observable实现，即使命令打算返回一个简单的值。
3. Is the Response Cached?
如果请求缓存被启用，如果缓存里面有这个请求的响应，该响应立即以Observable的形式被返回。
4. Is the Circuit Open?
当执行命令时，会首先检查断路器是否打开，如果打开将不执行命令直接路由到后退方法，如果关闭将检查是否有可用容量来执行命令。
5. Is the Thread Pool/Queue/Semaphore Full?
如果和该命令关联的线程池和队列（或信号量）是满的，命令将不会被执行，立即路由到后退方法。
6. HystrixObservableCommand.construct() or HystrixCommand.run()
hystrix通过你写的方法来向依赖发起请求，HystrixCommand.run()方法返回单一响应或抛出异常，HystrixObservableCommand.construct()方法
返回一个Observable对象，可以发出响应或发送一个onError通知。
如果这两个方法超出了命令的超时时间，线程将抛出一个TimeoutException（如果命令没有运行在自己的线程，一个单独的timer线程将抛异常）。
此时获取后退的方法值，如果这两个方法没有被取消或中断，它们最终的返回值将被抛弃。需要注意的是没有办法强迫潜在的线程停止工作，能够做到
最好的就是在JVM上抛出一个InterruptedException。如果被hystrix包装的代码不遵守InterruptedException，hystrix线程池里的线程将继续它的
工作，虽然客户端已经收到一个TimeoutException。这种行为能够填满hystrix的线程池，虽然负载被正确地丢弃了。许多Java http客户端库不解释
InterruptedException，所以请确保正确地配置了连接和读/写的超时时间。
如果命令没有抛出任何异常并且返回了一个响应，hystrix将返回这个响应在它执行一些日志和测量报告之后。对于run()方法，hystrix返回一个
Observable发出那个单一响应，然后做一个onCompleted通知。对于construct()方法，hystrix返回原始的Observable。
7. Calculate Circuit Health
hystrix向循环断路器报告成功、失败、拒绝和超时情况，它维护了一个滚动集合的计数器来计算统计情况。它使用这些统计情况来决定什么时候断路器
应该打开，在那一点它短路任何的后续请求直到一个恢复周期的时间已经逝去，然后在首次健康检查确定没有问题后，断路器将再次关闭。
8. Get the Fallback
hystrix尝试复位到你的回退方法无论什么时候当一个命令执行失败时。当一个异常从construct()和run()里面抛出，当由于断路器断开命令被短路时，
当命令的线程池和队列或信号量的容量都满了时，当命令执行超时时。写下你的回退方法来提供一个通用的响应，且不依赖于任何网络，从一个内存型
缓存或通过其它静态逻辑的形式。如果你在回退方法里必须进行网络调用，你应该以另外一种HystrixCommand或HystrixObservableCommand的方式来
进行。对于HystrixCommand，提供后退逻辑应该实现HystrixCommand.getFallback()，返回一个单一值。对于HystrixObservableCommand，提供后退
逻辑应该实现HystrixObservableCommand.resumeWithFallback()，它返回一个Observable对象，发出一个值或多个值。
如果回退方法返回一个响应，hystrix将把这个响应返回给调用方。对于HystrixCommand.getFallback()，将返回一个Observable对象，发出从回退方法
返回的值。对于HystrixObservableCommand.resumeWithFallback()，将返回从回退方法里返回的那个Observable对象。
如果你还没有实现一个回退方法，或者你的回退方法本身抛出一个异常，hystrix仍然会返回一个Observable对象，但是它不发出任何东西，立即以一个
onError通知而终止。通过这个通知，导致命令失败的异常被传回给调用方（回退方法也能失败是一个非常糟糕的实践，应该避免）。
你调用hystrix命令的方式不同，回退方法失败或不存在所导致的结果也不同，execute()将抛出一个异常，queue()将返回一个Future，如果你通过get()
方法获取返回值时将抛出一个异常，observe()返回一个Observable对象，当你订阅它时，将立即通过调用订阅者的onError方法而终止，toObservable()
返回一个Observable对象，当你订阅它时，将通过调用订阅者的onError方法而终止。
9. Return the Successful Response
如果命令成功执行，将以Observable对象的形式把一个或多个响应返回给调用方。取决于你调用方式的不同，这个Observable对象在返回给你之前可能
被转换过。
execute()，通过queue()获取Future然后再调用get()。
queue()，把Observable变成BlockingObservable然后再变成Future并返回。
observe()，立即订阅到Observable，然后开始执行命令的流程。返回一个Observable对象，重演发出和通知。
toObservable()，返回一个未改变的Observable对象，你必须订阅到它来真正地开始执行命令的流程。
Circuit Breaker
HystrixCommand或HystrixObservableCommand如何与HystrixCircuitBreaker交互，做出决定和逻辑的流程，循环断路器里的计数器如何做出行为。
循环回路打开/关闭的发生的精确方式如下：
假定通过回路的容量满足一个确定的阈值。HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()。
同时错误百分比超出了一个阈值。HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()。
此时循环断路器从关闭到打开。
当它打开时，所有指向该循环断路器的请求都会被短路。
在一段时间（HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()）之后，下一个请求让它通过（此时是半开状态），如果
请求失败，循环断路器回到打开状态持续一个睡眠窗口的时长，如果请求成功，循环断路器变为关闭状态，继续重复一开始的逻辑。
Isolation
hystrix采用隔板模式把依赖相互间隔离，并且限制对其中任何一个的并发访问。
Threads & Thread Pools
客户端库或网络调用在单独的线程上执行，这样把它们和主调线程（tomcat线程池）隔离开，以便调用者可以从一个花费很长时间执行的依赖处走开。
每个依赖都有自己的线程池，所以如果底层执行延时的话将只会塞满它自己的线程池。你也可以不使用线程池来防止失败，但是这要求客户端是可信
的，能够快速失败（网络连接/读取的超时时间和重试的配置）并且总是执行的很好。
选择线程和线程池来实现隔离有很多原因：
很多应用执行很多不同的后端服务，它们又调用很多由不同项目组开发的很多不同服务。
每个服务提供它自己的客户端库。
客户端库一直在改变。
客户端逻辑改变加入新的网络调用。
客户端库包含一些逻辑，像重试，数据解析，缓存（内存型或分布式）
客户端库趋向于是一个黑盒子，关于实现详情、网络访问模式、默认配置等等对用户不透明。
在真实的生产环境停止后得到的结论是，一些东西改变了，属性需要适配，或客户端库改变了它的行为。
即使客户端自己没有改变，服务自身能改变，它能影响性能特征，继而引起客户端的配置变的非法。
传递依赖能靠近一些不希望的和配置不正确的客户端库。
大多网络访问是同步执行的。
除了网络调用外，客户端代码也有可能失败或延时。
Benefits of Thread Pools
通过线程池里的线程进行隔离的好处：
应用程序与客户端分离，被完全保护起来了，依赖库的线程池可以单独被填满而不影响应用的其它部分。
应用可以以低得多的风险接受新的客户端库，如果出现问题，它被隔离到那个库，不会影响其它的。
当一个失败的客户端再次变得健康，线程池将会清空一次，应用立即恢复到健康性能，与之相反的是，当整个tomcat容器被压垮的话，
需要一个很长的时间恢复。
如果一个客户端库缺少配置，一个线程池的健康将快速地说明这一点（通过增加的错误、延时、超时、拒绝等），你可以处理它（实
时地通过动态属性）而不影响应用的功能。
如果一个客户端服务改变了性能特征（如果这经常发生的话将变成一个问题），它将依次引起一个调节属性（增大/减少超时时间，改
变重试次数等）的需求，性能会再次变的可见通过线程池的测量（错误、延时、超时、拒绝等），可以被处理而不影响其它的客户端，
请求，用户。
超出了隔离的好处外，有专用的线程池提供内建的并发，能够在同步客户端库的上面构建一个异步的门面。
简言之，线程池提供的隔离允许总是改变的和动态联合的客户端库和子系统的性能特征问题被优雅的处理而不引起停用。
注：尽管隔离是一个单独线程提供的，你的底层客户端代码应该也有超时时间，响应线程的中断，以便它不会无限期地阻塞并打满
hystrix的线程池。
Drawbacks of Thread Pools（线程池的弊端）
线程池的主要弊端是它添加了计算机科学的天花板。每一个命令执行涉及到排队、调度，在一个单独线程里执行涉及到上下文切换。
netflix在设计这个系统时，决定接受这个天花板的开销，来换取它带来的好处，相信它足够小，不会造成大的开销或性能影响。
Cost of Threads（线程的开销）
hystrix进行了延时测量，当它运行construct()或run()方法在子线程上和在父线程上。这种方式你可以看出来天花板的开销（线程，
测量，日志，循环断路器等）。

Semaphores
你可以使用信号量（或计数器）来限制对给定依赖的并发访问数目，代替使用线程池/队列的大小。这种不使用线程池来抛弃负载的
方式，不允许超时和走开，如果你信任客户端，仅想抛弃负载，可以使用这种方式。
HystrixCommand和HystrixObservableCommand在两个地方支持信号量：
回退：当接收回退方法的值时，也是在tomcat的主调线程上执行的。
执行：如果你设置了属性execution.isolation.strategy为SEMAPHORE，使用信号量而不是线程来限制调用命令的并发父线程的数量。
可以使用动态属性的方式来配置信号量的使用，决定多少个并发线程能执行。设置大小的计算方式和使用线程池是相似。
注意：如果一个依赖使用信号量隔离，然后变得延时，父线程将仍然阻塞直到底层的网络调用超时。
一旦数目达到限制，信号量拒绝将开始，但是填满该信号量的线程没办法走开。
Request Collapsing（请求折叠）
可以把一个请求折叠器放到一个HystrixCommand前面（HystrixCollapser是抽象父类）。使用它你能够把多个请求折叠进单个后端依赖调用。
Why Use Request Collapsing?
使用请求折叠来减少命令并发执行所需的线程和网络连接数目。请求折叠以一个自动化的方式来实现它，不强迫基于同一代码库的所有开发人员
来协调请求的手动批处理。
Global Context (Across All Tomcat Threads)
折叠的理想类型是在全局应用级别被完成，以便来自于任何用户、任何线程的请求能够被折叠在一起。如果你配置了一个HystrixCommand来支持
批处理用于任何请求上的用户对于同一个依赖获取电影速率，相同JVM中的任何用户线程发出了这样一个请求，hystrix将把这个请求和任何其它
请求一道添加进相同的折叠的网络调用。注意，折叠器将传递单个HystrixRequestContext对象给折叠的网络调用，所以下流的系统必须处理这
中情况，因为这将是一个有效的选项。
User Request Context (Single Tomcat Thread)
如果你配置一个HystrixCommand用来仅处理一个用户的批量请求，hystrix能够折叠来自单个线程的请求。例如，一个用户想为300视频对象加载
书签，不会去执行300个网络调用，hystrix会把它们结合到一个里面。
Object Modeling and Code Complexity
有时当你创建一个对象模型，使对消费者对象合理有意义，那么对于生产者的有效资源利用不会匹配的很好。例如，有300个视频对象的列表，依次
迭代它们并在每个对象上调用方法是一种很显然的对象模型，但是如果天真地这样实现，将导致在毫秒级别内几乎同时发起300个网络调用（很可能
使你的资源达到饱和）。如果把如何控制的代码放到开发当中，会使开发人员非常容易出错和低效，这也会导致api和对象模型非常奇怪，不符合人
们的思想模型和使用模式。
把折叠逻辑下放到hystrix层，你如何创建对象模型，以什么顺序调用，是否不同的开发者知道优化已完成或甚至需要被完成，都没有关系。方法可
以放到任何它觉得合适的地方，可以以任何符合使用习惯的方式被调用，折叠器将自动地批处理这些调用进入时间窗口。
What Is the Cost of Request Collapsing?
启用请求折叠的开销是在实际的命令被执行前有一个增加的延时。最大的开销是批处理窗口的尺寸。如果你有一个命令的
执行时间中位数是5ms，和一个10ms的批处理窗口，最坏的情况下执行时间可能变成15ms。一般情况下，一个请求不可能
恰巧在窗口刚刚打开时被提交，所以中位数处罚是窗口时间的一般，此时情形是5ms。这种开销是否值得的决定取决于正
在被执行的命令。一个高延时的命令对于这一小点额外的延时并不会觉得不可忍受。同样，一个给定命令上的并发数量是
关键：在支付罚款里没有看点，如果很少有多于1或2个的请求被批处理到一起。事实上在一个单线程里，顺序迭代折叠将
是一个主要的性能瓶颈，因为每一次迭代将等10ms的批处理窗口时间。然而，如果一个特殊的命令并发利用特别严重，能
批处理一打或甚至成百个调用到一起，此时的开销重得多由于增加的吞吐量，因为hystrix减少了它要求的线程数量和到
依赖的网络连接数量。
Request Caching
HystrixCommand和HystrixObservableCommand实现能定义一个缓存key，用来在一个请求上下文里，一个并发感知的方式，删除重复调用。
请求缓存的好处是，不同的代码路径能够执行hystrix命令而不用关心重复工作。这在一个大的代码库里面非常有用，许多开发者一起实现
功能的不同片段。许多代码路径都需要获取用户的Account对象，每个都可以发出一个像下面这样的请求，
Account account = new UserGetAccount(accountId).execute();或者
Observable<Account> accountObservable = new UserGetAccount(accountId).observe();
hystrix的RequestCache将执行底层的run()方法一次且仅一次，两个执行命令的线程将接收相同的数据尽快已经证明是不同的实例。
数据接收是一致的遍及一个请求里。对于命令的每一次执行，第一个响应被缓存，在同一个请求里的所有后续调用都返回该响应，而不会
存在返回一个不同值的可能性。
消除重复的线程执行，因为请求缓存位于construct()或run()方法调用前，hystrix能够在它们导致线程执行前删除重复调用。
如果hystrix不实现请求缓存功能，每个命令需要自己在construct()或run()方法里实现它，把它放到线程排队后执行。






















